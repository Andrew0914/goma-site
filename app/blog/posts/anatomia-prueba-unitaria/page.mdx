export const metadata = {
  title: "Anatom√≠a de una prueba unitaria",
  description: "El patr√≥n AAA tiene como objetivo dividir cada una de las pruebas en 3 fases: arrange, act y assert, que en espa√±ol ser√≠a: organizar, actuar y verficar",
  createAt: "2020-09-30",
};

<small className="text--muted text--sm ml--6">2020-09-30</small>
# Anatom√≠a de una prueba unitaria

**¬øC√≥mo escribir una prueba unitara?** A lo largo de este post conoceremos la estructura de una prueba unitaria, usualmente est√° representada por las fases de: arrange, act y assert (AAA), se abordar√°n las buenas pr√°cticas para estructurar tus pruebas y para nombrarlas, por √∫ltimo veremos como sacar provecho al framewrok de pruebas que est√©s utilizando.

## ¬øC√≥mo estructurar una prueba unitaria?

### Usando el patr√≥n AAA
El patr√≥n AAA tiene como objetivo dividir cada una de las pruebas en 3 fases: arrange, act y assert, que en espa√±ol ser√≠a: organizar, actuar y verficar, comencemos con un ejemplo para explicar cada una de estas partes:

> Los ejemplos en este post est√°n escritos en javascript usando el framewrok de pruebas JEST.

```javascript
//SUT
class Calculator {
    sum(first, second){
        return first + second
    }
}
it('Sum of twn numbers üß™', () => {
    // Arrange
    const calculator = new Calculator()
    const first = 10
    const second = 20
    // Act
    const result = calculator.sum(first , second)
    // Assert
    expect(result).toBe(30)
})
```

En el ejemplo anterior podemos ver que se est√° probando el m√©todo de una clase que realiza la suma de dos n√∫meros, y la prueba unitaria esta escrita con el patr√≥n AAA, unas de las mayores ventajas de escribir tus pruebas de esta manera, es que les puedes dar uniformidad a tus pruebas, y una vez que te acostumbras, tus pruebas se vuelven muy f√°ciles de entender.

La estructura es como sigue:

* **üõ†Ô∏è Arrange**: es donde se organiza, inicializa y prepara el sistema bajo pruebas y sus dependencia para tenerlo en el estado mas conveniente para nuestra prueba.
* **‚öôÔ∏è Act**: Es donde se ejecuta el m√©todo o la acci√≥n que va a producir el resultado que vamos a verificar.
* **‚úÖ Assert**: esta es la fase de verificaci√≥n, donde se va a confirmar que el resultado obtenido o generado en la fase anterior sea el resultado esperado.

Existe un patr√≥n homologo llamada **Give-When-Then**, que pr√°cticamente es lo mismo, cada una de las fases corresponde a cada una del patr√≥n AAA, la √∫nica difrencia es que es m√°s legible para personas no t√©cnicas, escribamos un enunciado de la prueba del ejemplo anterior siguiendo este patr√≥n:

> **Dado(given/arrange üõ†)** que tenemos un calculator y los numeros 10 y 20, **cuando(when/act ‚öô)** sumemos ambos numeros, **entonces (then/assert ‚úÖ)** el resultado debe ser 30.

En general es com√∫n iniciar una prueba por la fase de arrange, sin embargo, aunque al final el orden si debe conservarse, puedes comenzar a escribir la fase de assert primero si est√°s utilizando TDD.

> [TDD(test driven developement)](https://es.wikipedia.org/wiki/Desarrollo_guiado_por_pruebas) o desarrollo dirigido por pruebas: es una metodolog√≠a de desarrollo que consiste en escribir primero la prueba empezando por el resultado que deseas obtener y basado en eso escribir solo el c√≥digo de producci√≥n necesario para satisfacer dicha prueba.

## Evita tener m√°s de una fase de cada tipo

Debemos evitar tener mas de una de cada una de las fases del patr√≥n, en espec√≠fico tener mas de una fase **Act** nos indica que se est√°n verificando m√°s de un comportamiento por que se estar√≠a ejecutando m√°s de una acci√≥n.

Otra forma de tener multiples fases, es cuando tenemos una fase de **Act** donde se ejecuta una acci√≥n y en seguida una fase **Arrange** que utiliza el resultado obtenido anteriormente, de esta manera lo que estamos generando es una prueba de integracion, ya que estamos verificando varios comportamientos relacionados.

Como ya discutimos en posts pasados, una prueba unitaria verifica una √∫nica unidad de comportamiento, por eso, lo mejor es que si nos encontramos en estos casos, se debe separar esa prueba con m√∫ltiples fases en pruebas individuales que verifiquen un comportamiento a la vez.

![Evita tener mas de 1 fase de cada tipo](/images/posts/unit_test_phases_avoid.png)
<small>Evita tener mas de 1 fase de cada tipo</small>

## Evita usar sentencias if dentro de las pruebas
Similar a tener muchas fases de **AAA**, podemos encontrarnos una prueba unitaria con una sentencia `if` dentro, pero esto es un atipatr√≥n, ya que una prueba unitaria debe ser una secuencia simple de pasos sin ramificaciones de casos.

Una sentencia `if` indica que se estan verificando m√°s de un comportamiento a la vez, cuando nos encontremos en esta situaci√≥n, debemos dividir esa prueba en m√∫ltiples pruebas que verifiquen cada caso de manera individual.

A diferencia del punto anterior sobre utilizar multiples fases **AAA**, que est√° permitido en pruebas de integraci√≥n, el uso de `if` dentro de pruebas unitarias y de integraci√≥n no es correcto, ya que no trae ning√∫n beneficio, al contrario, aumenta el costo de mantenimiento y se vuelven mas dif√≠ciles de entender.


## ¬øCu√°n larga debe ser cada secci√≥n o fase de una prueba unitaria?

Podr√≠amos preguntarnos cual deber√≠a ser la extensi√≥n de cada una de las fases de nuestra prueba, y que tanto debemos incluir en cada una de las fases.

**La fase de Arrange usualmente es la mas larga** de todas las fases, porqu√© contiene toda la configuraci√≥n inicial que le vas a dar a tu sistema bajo pruebas antes de verificarlo, sin embargo, si llega a ser muy extensa, siempre puedes extraer las configuraciones a m√©todos privados y mandarlos a llamar, o si estas utilizando muchos objectos/estructuras de prueba ‚Äútext fixtures‚Äù, tambi√©n siempre puedes extraerlos y ponerlos en clases o m√©todos factory.

**Cuidado ‚ö†Ô∏è con que en tu fase de Act incluyas mas de una l√≠nea de ejecuci√≥n**, el tener m√°s de una l√≠nea de ejcuci√≥n en esta fase indica que est√°s probando m√°s de un comportamiento a la vez; aunque si puede presentarse el caso donde nesecitas ejecutar m√°s de una l√≠nea por que es necesario para probar un solo comportamiento, en este caso nos econtramos con un problema de dise√±o ya que esas dos o m√°s lineas deber√≠an estar encapsuladas en un m√©todo que ejecute el comportamientio.

Ejemplo:

```javascript
it("Successfull purchase when is enough üíµ", () => {
  //Arrange üõ†
  const inventory = new Inventory();
  inventory.add(Product.Beer, 10);
  const customer = new customer();
  //Act ‚öôÔ∏è  these two lines should be ecapsulate in a method
  const success = customer.purchase(inventory, Product.Beer, 5);
  inventory.remove(success, Product.Beer, 5);
  //Assert ‚úÖ
  expect(success).toBeTruthy();
  expect(inventory.get(Product.Beer)).toEqual(5);
});
```

Podemos ver que en el ejemplo anterior dentro de la fase Act hay 2 l√≠neas que efectuan una compra, primero realiza la compra y despu√©s disminuye el inventario, pero esto es un error de dise√±o, porqu√© usar estas l√≠neas de manera separada pueden llevar nuestro sistema a un estado inconsistente.

**¬øCu√°ntas verificaciones debe haber en la fase Assert?** Dada la definici√≥n que hemos manejado de que una prueba unitaria verifica un √∫nico comportamiento de manera individual, podemos llegar a pensar que debemos tener una √∫nica verificaci√≥n, incluso es una idea muy com√∫n que suelen tener muchos desarrolladores.

Pero dado que estamos verificando una unidad de comportamiento, este puede exhibir m√°s de una salida que nesecite ser veirficada, por tanto mientras se est√© probando el mismo comportamiento puedes tener una o m√°s verificaciones en la fase de Assert.

## La cuarta fase de las pruebas unitarias

Existe una cuarta fase para las pruebas unitarias no incluida en los ejemplos anteriores, se llama : **‚Äúteardown phase‚Äú,** o la fase de destrucci√≥n o limpieza.

Esta fase se utiliza para destrucir o deshacer los cambios generados tras la ejecuci√≥n de una prueba unitaria, puede haber una fase de teardown por cada prueba o una fase para un set de pruebas, sin embargo si nosotros estamos creando adecuadamente nuestras pruebas, eliminando dependencias compartidas que generalmente son dependencias out-of-process, estamos elimando posibles side-effects que neseciten ser limpiados.

Con todo lo anterior, la mayor parte del tiempo no es necesaria esta fase de teardown.

## Estructurar bien la prueba unitaria

Para tener identificado perfectamente cada una de las partes de una prueba unitaria es recomendable primero identificar f√°cilmente el sistema bajo pruebas o el m√©todo bajo prueba que est√°s verificando, ya que este ocupa uno de los roles m√°s importantes dentro de la prueba, para ello puedes nombrar este sistema bajo pruebas con la variable sut, ejemplo:

```javascript
it("Successfull purchase when is enough üíµ", () => {
  //Arrange üõ†
  const inventory = new Inventory();
    const sut = new customer();
    ...
});
```	

En el ejemplo de arriba la clase que se va a verificar es la clase Customer, por tanto, es una buena pr√°ctica nombrar la variable **sut** para tenerla identificada.

Otra buena pr√°ctica para tener identificada cada una de las fases en una prueba unitaria, es separar las fases por un espacio o etiquetar con comentarios cada fase, personalmente prefiero esta √∫ltima, y es as√≠ como estan los ejemplos en este post, de esta manera puedes ocupar saltos de linea y separar las fases de manera sencilla.

```javascript	
it("A unit test üß™, () => {
  //Arrange üõ†
  //Act ‚öôÔ∏è
  //Assert ‚úÖ
});
```

## Buenas pr√°cticas, utilizando tu framewrok de pruebas favorito

Sin importar el framewrok que utilizamos, para el lenguaje que sea, existen ciertas buenas pr√°cticas que en la mayor√≠a de ellos se pueden adoptar, y el framewrok en s√≠ te da herramientas para implementarlas.

La primera es usar y reutilizar adecuandamente los llamados [test fixtures](https://en.wikipedia.org/wiki/Test_fixture).

Generalmente solemos crear estos objetos o tests fixtures en la fase de Arrange de las pruebas para poder verificar el caso que se est√° probando, sin embargo, muchas veces ocupamos esos objetos en m√°s de una prueba, hay que tener en consideraci√≥n lo siguinete:

Si nostros generamos estos test fixtures en una fase inicial de todo el set de pruebas, como un √∫nico m√©todo setup o un constructor, podr√≠amos estar creando un dependencia compartida para las pruebas, al estar m√°s de una de ellas utilizando la misma instancia de un objeto, ejemplo:

```javascript
let inventory;

beforeAll(() => {
  inventory = new Inventory();
});

it("Successfull purchase when is enough üíµ", () => {
  //Arrange üõ†
  ...
  const customer = new customer();
  //Act ‚öôÔ∏è 
  customer.purchase(inventory, Product.Beer, 5);
  ...
});
```

En el ejemplo anterior estamos generando una √∫nica instancia del inventario para todas las pruebas, por tanto cada prueba que utilice esa instancia, estar√≠a compartiendo y modificando el estado del inventario, generando un alto nivel de acoplamiento entre pruebas, pudiendo afectar el resultado de otras

En este caso, lo que se recomienda es tener clases factory u objetos madre que construyan y devuelvan instancias neuvas de estos test fixtures, de esta manera, podemos reutilizar la creaci√≥n de estos sin utilizar las mismas instancias.

Otra desventaja de tener test fixtures compartidas para las pruebas y creados en el setup inicial, es que las pruebas se vuelven menos legibles al reducir la fase de arrange usando un setup inicial, ya que tendr√≠as qie buscar fuera de la prueba como es que est√° configurado el estado inicial de la misma.

## Nombrando tus pruebas unitarias.

Depende el framework que utilices, tiene distintas maneras de nombrar cada una de tus pruebas unitarias, por ejemplo para java utilizando [Junit](https://junit.org/junit5/), tienes que crear una clase para tu set de pruebas generalmente nombrada igual que la clase bajo pruebas con el sufijo test, ejemplo: `Customer -> CustomerTest`

```java
public CustomerTest{
  @Test
  metodoBajoPruebas_escenario_resultadoEsperado(){
      ...
  }
}
```	
Y cada m√©todo es una prueba y el nombre de ese m√©todo es lo que describe la prueba, existen formas cl√°sicas pero muy r√≠gidas de darles nombre, sin embargo en este post les comparto una peque√±a gu√≠a m√°s practica y que le da m√°s significado a tus pruebas.

Este tema en particular es la raz√≥n por la cual eleg√≠ para este post utilizar javascript y [Jest](https://jestjs.io/), ya que te permite escribir frases normales para nombrar tus pruebas.

La forma cl√°sica de nombrar una prueba es: `MetodoBajoPruebas_Scenario_ResultadoEsperado` en lenguajes como java, esto hace que se tenga una rejilla o estructura muy r√≠gida que no le de el sentido adecuado, veamos un ejemplo utilizando js y el enfoque tradicional; supongamos que tenemos una clase Calculator con un m√©todo que suma 2 n√∫meros:

```javascript
class Calculator {
  sum(first, second){
      return first + second
  }
}
// Test üß™
it('sum two numbers return sum', () => {...})
```
	
Podr√° parecer l√≥gico para un programador, pero para una persona no t√©nica se vuelve algo complicada de leer, incluso para alguien nuevo en el proyecto puede costarle entender ya que no domina el sistema.

Una mejor forma de nombrar tus pruebas unitarias es utilizar frases simples y planas en ingl√©s o en el idioma que prefieras, aqu√≠ la forma de escribir pruebas en JEST nos ayuda, transformemos el ejemplo anterior usando este enfoque:

```javascript
// Test üß™
it('Sum of tow numbers', () => {...})
```

Ahora es mucho m√°s sencillo de leer,pero ¬øQu√© reglas debo seguir para considerar que he nombrado bien una prueba?, comparto la siguiente gu√≠a obtenida de libro:

* ‚úÖ No seguir una estructura r√≠gida en donde tengamos que embonar la descripci√≥n de un comportamiento complejo, sientanse libres de escribir una frase con m√°s significado.
* ‚úÖ Nombra la prueba como si se la estuvieras explicando a alguien no t√©cnico/programador.
* ‚úÖ No pongas el nombre de lo que est√°s probando, mas bien describe el comportamiento que est√°s verificando en una frase sencilla.
* ‚úÖ Recuerda que cada prueba verifica un comportamiento, que es un hecho, por tanto esribelas denotando lo que es y no lo que podr√≠a o se desear√≠a que fuera.

**Ejemplo**: supongamos que tenemos un m√©todo que recibe una edad de una persona y te devuelve si esta es mayor de edad (+18 a√±os), si queremos realizar una prueba unitaria de este m√©todo y nombrarla siguiendo la gu√≠a anterior, quedar√≠a :

```javascript
// Test ‚úÖ
it('A person under 18 is a minor', () => {...})
// Test ‚ùå
it('A person under the age of 18 should be a minor', () => {...})
```

## M√°s buenas pr√°cticas importantes

En la gran mayor√≠a de frameworks, existe forma de parametrizar tus pruebas, esto es, escribes una √∫nica prueba que puede recibir parametros y estar verificando distintos casos, branches o comportamientos por cada conjunto de parametros, asi que es una buena opci√≥n aprovechar esta caracter√≠stica si tu framework la ofrece.

Otra caracter√≠stica importante es el aprovechamiento m√°ximo de la librer√≠a de assertions que ofrezca el framework, las assertions son los m√©todos que ocupamos para verificar o comparar el resultado esperado, estos se usan en la fase Assert, ejemplo(tomando JEST como base):

```javascript	
it('A unit test', () => {
  //  Arrange
  // Act
  // Assert
  expect(somnething).toBe(value)
  expect(somnething).toHaveBeenCalled()
  expect(somnething).toHaveReturned()
  expect(somnething).toBeFalsy()
  expect(somnething).toBeGreaterThan(number | bigint)
  expect(somnething).toBeLessThan(number | bigint)
  expect(somnething).toBeNull()
  expect(somnething).toBeTruthy()
})
```

La gran mayor√≠a de los framewroks cuentan con poderosas librer√≠as de assertions para verificar tus pruebas unitarias, desde assertions por valor, numer√≠cas, de tipo, etc√©tera, aqu√≠ pueden ver todas las que tiene JEST.

Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro: 

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).
