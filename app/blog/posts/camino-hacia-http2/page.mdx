export const metadata = {
  title: "El camino hacia HTTP/2, ¬øC√≥mo funciona?|",
  description: "HTTP por sus siglas en ingl√©s Hypertext Transfer Protocol, es el protocolo gen√©rico m√°s utilizado para el intercambio de informaci√≥n cliente servidor.",
  createAt: "2020-09-13",
};

<small className="text--muted text--sm ml--6">2020-09-13</small>

# El camino hacia HTTP/2, ¬øC√≥mo funciona?

HTTP por sus siglas en ingl√©s **Hypertext Transfer Protocol**, es el protocolo gen√©rico m√°s utilizado para el intercambio de informaci√≥n cliente servidor.

![Protocolo HTTP ](/images/posts/HTTP.png)

## ¬øCuales son sus caracter√≠sticas principales?

* La comunicaci√≥n consiste en una petici√≥n y una respuesta.
* Se utiliza para la transferencia de hipertexto, js, css, datos e hipermedia.
* Utiliza verbos para que el cliente pueda realizar peticiones.
* Cada objeto intercambiado se clasifica por su tipo MIME.
* Es ‚ÄúStateless‚Äù, cada petici√≥n es independiente.
* ‚ÄúNot connection-oriented‚Äù, no necesita datos previos para iniciar una transmisi√≥n.
* Cada recurso al que se le aplican los verbos est√° **identificado** por un URL.
* Corre en la capa de aplicaci√≥n.

## Un poco de historia

En la d√©cada de 1930 el ingeniero estadounidense **Vannebar Bush** tuvo la idea que seria precursora de la **world wide web**, era un sistema llamado **MEMEX**, que en teor√≠a servir√≠a para almacenar conocimiento en documentos que tuvieran asociaciones contextuales entre s√≠.

Para el a√±o de **1965 Ted Nelson** tomando como base las ideas de Vannebar acu√±√≥ el primer concepto de hypertexto:

> Material escrito o pict√≥rico interconectado de una manera compleja que no lo hace conveniente para escribirlo en papel. Puede contener √≠ndices o mapas de su contenido y sus interrelaciones;  puede contener anotaciones, adiciones y notas a pie de p√°gina.

Para el a√±o **1989 Tim Berners Lee**, quien era un ingeniero del [CERN](https://home.cern/), cre√≥ el protocolo de HTTP que utilizamos hoy en d√≠a y se liber√≥ la primer versi√≥n **HTTP 0.9** que consist√≠a en un intercambio simple de una petici√≥n **GET(solo esa exist√≠a)** y una respuesta en texto plano.

![Esquema del funcionamiento de HTTP 0.9](/images/posts/http_09.png)
<small>Esquema del funcionamiento de HTTP 0.9</small>

R√°pidamente el uso del protocolo se extendi√≥ y para 1995 ya estaba siendo utilizado en mas de 18000 servidores, lo cual gener√≥ necesidades nuevas y para 1996 se libero la versi√≥n de [HTTP 1.0](https://tools.ietf.org/html/rfc1945) que paso a ser una herramientas mas robusto a diferencia de su predecesor que era muy simple.

Esta nueva versi√≥n agreg√≥ mas verbos(**POST, PUT, DELETE ‚Ä¶**), el uso de encabezados, pero no paso mucho para que se requiriera una nueva actualizaci√≥n y para 1997 se libero la versi√≥n de **HTTP 1.1** que entre otras cosas trajo una mejora significativa en el performance al evitar tener que reconectar tras recibir una respuesta.

![Esquema de HTTP 1.1](/images/posts/http_1_1.png)
<small>Esquema de HTTP 1.1</small>


**Con la versi√≥n de HTTP 1.1 duramos poco m√°s de 20 a√±os üò±** antes de que apareciera la siguiente versi√≥n, durante este tiempo la web jam√°s se detuvo, siempre con tendencia a m√°s: m√°s memoria, m√°s objetos en los sitios web, mas complejidad y mas intercambio de datos; sin embargo el protocolo si se estanc√≥ por muchos a√±os en la misma versi√≥n, dando as√≠ paso a una suerte de muchas t√©cnicas y expertos que intentaban optimizar las aplicaciones y sitios web para lo que pod√≠a ofrecer esta versi√≥n.


## SPDY ‚ÄúSPeeDY‚Äù

La duraci√≥n que tuvo la versi√≥n de HTTP 1.1 por m√°s de 20 a√±os, no quiere decir que no hubo muchos intentos de mejorar o iniciativas para crear una nueva versi√≥n, solo que la mayor√≠a era desechada o no era apoyada por la comunidad.

En el a√±o de 2009 surge **SPDY** tras varios experimentos por parte del equipo de **google chrome**, fue el intento de mejorar el protocolo m√°s aceptado, tanto que estaba encaminado a convertirse en el nuevo est√°ndar siendo aceptado por varios navegadores y proveedores de servicios.

Fue dise√±ado para minimizar la latencia con flujos multiplexados, priorizaci√≥n de solicitudes y compresi√≥n de encabezado HTTP; en sus primeros experimentos se cargaron p√°ginas un 55% m√°s r√°pido.

## ¬øPor qu√© no se convirti√≥ en el est√°ndar?

* Google decidi√≥ no darle m√°s soporte por que ya se estaba trabajando en HTTP2.
* Su algoritmo de compresi√≥n de encabezados fue victima del ataque [CRIME](https://es.wikipedia.org/wiki/CRIME)
* Sin embargo SPDY estableci√≥ todas las bases para lo que ser√≠a HTTP 2

## HTTP2
[HTTP 2](https://tools.ietf.org/html/rfc7540) es el cambio de versi√≥n que necesitaba el protocolo, se liber√≥ en 2015 oficialmente, lo cual nos dice que lleva ya 5 a√±os a la fecha que se escribe este blog, y aun todav√≠a muchos desarrolladores, aplicaciones y algunos frameworks no lo implementan; las motivaciones principales de HTTP 2 son:

* Multiplexaci√≥n de peticiones y respuestas.
* Compresi√≥n de encabezados para minimizar el overhead.
* Priorizaci√≥n de peticiones.
* Push de servidor.

Como vimos en la explicaci√≥n de SPDY podemos apreciar que realmente este √∫ltimo estableci√≥ el punto de partida para lo que ser√≠a HTTP 2.

En general lo que busca HTTP 2 es mejorar el performance, a trav√©s de distintas caracter√≠sticas de 7 caracter√≠sticas clave.

## ¬øPor qu√© HTTP 2 y no HTTP 1.2 ?
Descubriremos con mas detalle el por que, pero de manera general es que HTTP 2 se comunica en formato binario, mientras que HTTP 1.1 en texto plano, lo cual hace evidente la incompatibilidad para comunicarse y es denotado por el cambio de versi√≥n.

 ![HTTP2 VS HTTP 1.](/images/posts/http2_vs_http1.png)
<small>HTTP2 VS HTTP 1.2</small>

### 1. Capa de enmarcado binario
La base de todas las mejoras del protocolo es la nueva forma de encapsular y enviar los mensajes en una capa de enmarcado binario, que a diferencia de las versiones anteriores que los mensajes eran enviados en texto plano, ahora se env√≠an peque√±as unidades conocidas como __‚Äúframes‚Äù__ en formato binario, estas peque√±as unidades son fragmentos que componen un mensaje mas grande ya sea una petici√≥n o una respuesta.

![Enmarcado binario](/images/posts/enmarcado_binario.png)
<small>Fuente: [capa_de_enmarcado_binario](https://developers.google.com/web/fundamentals/performance/http2#capa_de_enmarcado_binario)</small>

### 2. Transmisiones mensajes y frames
Hay que conocer 3 conceptos base para entender como funciona la capa de enmarcado binario y como se establece la comunicaci√≥n :

* **Stream**: es un flujo bidireccional de bytes dentro de una conexi√≥n establecida.
* **Mensaje**: es un mensaje HTTP l√≥gico, es decir un ‚Äúrequest‚Äù o un ‚Äúresponse‚Äù.
* **Frame**: Es la unidad m√≠nima de comunicaci√≥n y contiene la data a transportar.(HTTP 2 utiliza varios tipos de frame con un objetivo especifico que sirven para transportar determinado tipo de informaci√≥n)

![Transmisiones, mensajes y frames](/images/posts/binary_frame.png)
<small>Fuente: [Transmisiones, mensajes y frames](https://developers.google.com/web/fundamentals/performance/http2#transmisiones_mensajes_y_marcos)</small>

### 3. Multiplexaci√≥n de transmisiones
Antes de la versi√≥n de HTTP 2, es decir, en la versi√≥n de HTTP 1.1 si tu quer√≠as realizar solicitudes paralelas ten√≠as que abrir tantas conexiones como solicitudes desearas hacer y cada una de esas conexiones no puede ser usada hasta que no haya una respuesta a la solicitud enviada a trav√©s de ella.

Ahora con HTTP 2 las transmisiones son multiplexadas, y gracias al enmarcado binario, dividir la informaci√≥n transmitida en peque√±as unidades (frames) estos pueden ser enviados de manera multiplexada e intercalada, logrando as√≠ poder estar realizando varias peticiones y recibiendo respuestas al mismo tiempo a trav√©s de una conexi√≥n.

![Multiplexaci√≥n de transmisiones](/images/posts/http_multiplexor.png)
<small>Fuente:  [Multiplexaci√≥n de transmisiones](https://developers.google.com/web/fundamentals/performance/http2#transmisiones_mensajes_y_marcos)</small>



### 4. Priorizaci√≥n de transmisiones
En un sitio web o aplicaci√≥n web es casi seguro que haya recursos mas cr√≠ticos que otros, por ejemplo: el js que le da funcionamiento a toda la aplicaci√≥n es m√°s importante que una imagen al pie de p√°gina.

HTTP 2 tiene un mecanismo para poder indicar prioridades de los recursos mas cr√≠ticos para tu sitio web o aplicaci√≥n, que es representada a trav√©s de un √°rbol de prioridad que se expresa en unos [frames especiales con informaci√≥n de dicha priorizaci√≥n](https://tools.ietf.org/html/rfc7540#section-6.3).

![√°rbol de priodirdad](/images/posts/arbol_prioridad.png)
<small>Representaci√≥n de un √°rbol de prioridad. </small>

La prioridad de una transmisi√≥n esta en funci√≥n de la dependencia que tengan entre s√≠ y de un peso asociado que expresa mayor o menor importancia, deber√°n primero cubrirse las dependencias y luego tomar en cuenta los pesos.

> Cabe aclarar que varias de las caracter√≠sticas mencionadas, lo que hace HTTP 2 es ofrecer el mecanismo para comunicar, por ejemplo: la priorizaci√≥n, pero la implementaci√≥n de tomar en cuenta o no esta prioridad es del cliente(web browser por ejemplo) o el servidor.

### 5. Una conexi√≥n por origen
En la versi√≥n pasada, HTTP 1.1 uno era necesario abrir una conexi√≥n por cada petici√≥n y esperar a que fuera respondida para poder utilizar esa conexi√≥n para realizar otra petici√≥n.

Dado las ventajas que ofrece la forma de enviar los mensajes en peque√±os fragmentos y la multiplexaci√≥n completa de las transmisiones, no es necesario estar abriendo tantas conexiones como peticiones, si no que por el contrario se establece una √∫nica conexi√≥n persistente que dura toda la sesi√≥n.

![Estableciendo conexiones HTTP 1.1 vs HTTP 2](/images/posts/http_connection.png)
<small>Estableciendo conexiones HTTP 1.1 vs HTTP 2</small>

### 6. Control de flujo

Un control de flujo en general dentro de un sistema es un mecanismo para evitar que se abrume al receptor con datos que no nesecita, no quiere o no pueda procesar.

HTTP 2 ofrece un mecanismo para poder comunicar dicho control de flujo, esto es importante por ejemplo para la caracter√≠stica de ‚ÄúPush de servidor‚Äù que ofrece tambi√©n el protcolo.

De nuevo como ya expliqu√© HTTP 2 solo ofrece el mecanismo para comunicar el control de flujo pero no el algoritmo que lo determina.

El control de flujo aplica solo para un tipo espec√≠fico de frame, el tipo [DATA](https://tools.ietf.org/html/rfc7540#section-6.1) y se comunica a trav√©s de los frames de tipo [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5) al inicio o se va actualizando con los frames de tipo [WINDOW_UPDATE](https://tools.ietf.org/html/rfc7540#section-6.9).

El control de flujo consiste en actualizar un valor conocido como ‚Äútama√±o de ventana‚Äù este determina que tanto flujo puede aceptar el receptor, quien recibe es quien indica su propio tama√±o de ventana y este control de flujo se aplica para cada stream y por toda la conexi√≥n.

![Flujo de control](/images/posts/flow_control.png)

> ¬°Es muy importante (incluso cr√≠tico) en muchos sistemas prevenir la sobrecarga! ‚ö†

### 7. Push de servidor
Otra de las caracter√≠sticas m√°s relevantes es que HTTP 2 tiene el poder de enviar m√°s de una respuesta para una solicitud del cliente, pudiendo as√≠ enviar recursos adicionales de manera pro activa al cliente a trav√©s de un mecanismos conocido como PUSH de servidor, esto sin que el cliente lo pida explicita mente.

Cuando el cliente solicita algo, por ejemplo, el servidor puede ya conocer con esa petici√≥n que el cliente necesitar√° otro recurso como un javascript o un css, sin embargo, no se hace PUSH solo por hacerlo si no que existe una serie de pautas para esto.

Primero el servidor tuvo que haber mandado un frame de tipo [PROMISE](https://tools.ietf.org/html/rfc7540#section-6.6) avisando al cliente que le mandar√° un PUSH, en este frame viene toda la informaci√≥n para que el cliente determine si lo acepta o no.

Los criterios necesarios para determinar a que recursos se le hacen push pueden ser diversos y ser√°n determinados por el servidor, as√≠ mismo los criterios del cliente para aceptarlo o declinar lo tambi√©n, por ejemplo aqu√≠ puede influir el control de flujo o la prioridad.

Los recursos que son mandadnos en un PUSH se van directamente al cach√© del cliente y no existen APIs o callbacks para determinar si lleg√≥ algo.

![Push de servidor](/images/posts/server_push.png)

<small>Fuente: [Server push](https://developers.google.com/web/fundamentals/performance/http2?hl=es#servidor_push)</small>

### 8. Compresi√≥n de encabezados
Cada transferencia de un mensaje HTTP viene acompa√±ada de un conjunto de encabezados, en versiones pasadas del protocolo estos encabezados ven√≠an en texto plano, ahora vienen en un frame de tipo [HEADERS](https://tools.ietf.org/html/rfc7540#section-6.2).

Como ya dije, antes estos encabezados se enviaban en texto plano agregando un overhead de entre 500 y 800 bytes por cada mensaje, ahora estos encabezados son comprimidos y a trav√©s de unas tablas que sirven para almacenar, rastrear y reutilizar encabezados que ya hayan sido enviados previamente, la transferencia de estos metadatos es optimizada.

De esta manera los encabezados se van heredando entre peticiones y solo se agrega el overhead de los nuevos encabezados, ya que muchos de estos suelen ser repetitivos, adem√°s se les aplica el algoritmo de compresi√≥n que los hace todav√≠a m√°s ligeros.

![Compresi√≥n de encabezados](/images/posts/header_compression.png)

<small>Fuente: [Compresi√≥n de encabezados](https://developers.google.com/web/fundamentals/performance/http2?hl=es#compresi%C3%B3n_de_encabezado)</small>

## Datos para programadores üßë‚Äçüíª
Ya hemos visto las caracter√≠sticas generales del protocolo, conocimos un poco de sus historia y su evoluci√≥n y finalmente entendimos a detalle cuales son sus principales caracter√≠sticas de esta nueva versi√≥n, pero quien escribe este post es un programador y probablemente al igual que a mi les surgen muchas preguntas.

### ¬øHTTP 2 elimina la necesidad de los [Web sockets](https://developer.mozilla.org/es/docs/Web/API/WebSockets_API)?
Podemos llegar a pensar que como HTTP 2 mantiene una conexi√≥n persistente y se pueden enviar los PUSH de servidor es as√≠, pero recordemos que los PUSH de servidor solo sirven para enviar recursos que van directamente a cach√© y no hay manera de pre procesarlos, un [API](https://www.redhat.com/es/topics/api/what-are-application-programming-interfaces) o un [callback](https://es.wikipedia.org/wiki/Callback_(inform%C3%A1tica)) que nos de una notificaci√≥n

Un web socket tambi√©n mantiene una conexi√≥n persistente, pero en la mayor√≠a de lenguajes y frameworks si existen APIs o librer√≠as que te permiten notificar el envi√≥ de un push o broadcast por parte del websocket, por lo cual los websockets pueden ser utilizados para el envi√≥ de datos de aplicaci√≥n, como un json, e interactuar con un API remota a trav√©s de esa conexi√≥n.

![HTTP vs WS](/images/posts/http_vs_ws.png)

### ¬øPero siguen funcionando los web sockets con HTTP 2?
Si, ya que anteriormente para establecer una conexi√≥n a un web socket se enviaba una petici√≥n de tipo GET y se recib√≠a un c√≥digo 101 indicando el √©xito y cambio de protocolo.

Ahora lo que se realiza es una petici√≥n de tipo CONNECT y se responde un c√≥digo 200 indicado el cambio exitoso de protocolo.

### ¬øBeneficia a las APIS de servicio web?
S√≠, por lo menos a las m√°s populares : [REST](https://bbvaopen4u.com/es/actualidad/api-rest-que-es-y-cuales-son-sus-ventajas-en-el-desarrollo-de-proyectos), [GRAPHQL](https://graphql.org/) y [SOAP](https://es.wikipedia.org/wiki/Simple_Object_Access_Protocol), en general las primeras dos al estar basadas en la sem√°ntica de HTTP el cambio de protocolo es totalmente transparente y se ven beneficiadas por todas las mejoras.

Para las apis de tipo SOAP si es que se comunican con el protocolo HTTP 2 tambi√©n ser√°n beneficiadas.


### ¬øCuales ser√≠an las buenas pr√°cticas con este protocolo?
He realizado un peque√±o benchmark que demuestra como algunas viejas buenas pr√°cticas ya se vuelven anti patrones para esta versi√≥n del protocolo.

Este benchmark lo pueden ver explicado en el v√≠deo adjunto del final de este post, por ahora les dejo la diapositiva con el listado de buenas pr√°cticas y anti patrones:

![Buenas pr√°cticas y anti patrones](/images/posts/good_practices_http.png)

### ¬øLo soportan todos los navegadores?
Si, pr√°cticamente todos los m√°s usados: https://caniuse.com/http2

### Algunos frameworks que lo soportan

![Frameworks que soportan HTTP 2](/images/posts/http2_frameworks.png)
<small>Frameworks que soportan HTTP </small>

### Referencias:

* [Introducci√≥n a HTTP/2](https://developers.google.com/web/fundamentals/performance/http2)
* [¬øQue es el protocolo TCP?](https://es.ccm.net/contents/281-protocolo-tcp#que-es-el-protocolo-tcp)
* [Video: El algoritmo Huffman](https://www.youtube.com/watch?v=hWCjkZ04NWE)
* [HTTP y sus generalidades](https://developer.mozilla.org/es/docs/Web/HTTP/Overview)
* [RFC1945](https://tools.ietf.org/html/rfc1945)
* [RFC7540](https://tools.ietf.org/html/rfc7540)
* [RFC2616](https://tools.ietf.org/html/rfc2616)
* [¬øQu√© es HTTP/2?](https://somostechies.com/que-es-http2/)
* [HTTP/2 is here, let‚Äôs optimize! ‚Äì Velocity SC 2015](https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/edit#slide=id.gfd0e3427_2_119)
* [HTTP resource-inlining](https://hpbn.co/http1x/#resource-inlining)
* [Blog post oficial de SPDY](https://blog.chromium.org/2009/11/2x-faster-web.html)
* [WebSockets, HTTP/2, and SSE](https://medium.com/axiomzenteam/websockets-http-2-and-sse-5c24ae4d9d96)
* [Understanding REST, SOAP, RPC AND GRAPHQL APIS](https://apisyouwonthate.com/blog/understanding-rpc-rest-and-graphql)
* [HTTP/2 WebSockets](https://medium.com/@pgjones/http-2-websockets-81ae3aab36dd)
* [The right way to bundle your assets](https://medium.com/@asyncmax/the-right-way-to-bundle-your-assets-for-faster-sites-over-http-2-437c37efe3ff)
* [Performance best practices HTTP 2](https://deliciousbrains.com/performance-best-practices-http2/)
* [Learning HTTP guide for beginners](https://www.amazon.com/Learning-HTTP-Practical-Guide-Beginners/dp/1491962445)
* üìñ https://g.co/kgs/Vbxz5r
* üìñ https://g.co/kgs/C2tDcg

<VideoPreview videoId="CvVCMq2Q3Es"  height={320}/>
