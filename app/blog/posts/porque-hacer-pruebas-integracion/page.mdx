export const metadata = {
  title: "¬øPor qu√© hacer pruebas de integraci√≥n?",
  description: "Las pruebas de integraci√≥n juegan un papel importante en nuestra suite de pruebas", createAt: "2021-03-05",
};

<small className="text--muted text--sm ml--6">2021-03-05</small>

# ¬øPor qu√© hacer pruebas de integraci√≥n?

Nunca podremos confiar que un sistema funciona en su totalidad, solo con pruebas unitarias, aunque estas son eficientes para verificar la l√≥gica de negocios no es suficiente.

Se debe verificar como diferentes partes del sistema dse integran entre s√≠ y con elementos externos, como una base de datos y para ello tenemos las pruebas de integraci√≥n.

Las pruebas de integraci√≥n juegan un papel importante en nuestra suite de pruebas, como ya dijimos en el post <Link href="blog/posts/que-es-una-prueba-unitaria">¬øQu√© es una prueba unitaria? üß™</Link> las pruebas unitarias deben cumplir los siguientes criterios:

* üß© Debe verificar una pieza de comportamiento
* ‚ö° Debe hacerlo r√°pido
* üì¶ Debe hacerlo de manera aislada una prueba de otra

Si alguna de las anteriores no se cumple, entonces cae en la categor√≠a de prueba de integraci√≥n, en general una prueba de integraci√≥n verifica como tu sistema se integra con dependencias out-of-process.

Recordando el diagrama que utilizamos en el post anterior, el cuadrante que le corresponde es el siguiente:

![donde van las pruebas de integraci√≥n](/images/posts/integration_tests_position.png)

Como sabemos las pruebas unitarias deben enfocarse en la l√≥gica de negocios o los modelos, mientras que las pruebas de integraci√≥n se enfocan en los controladores donde se orquestan las interacciones de la l√≥gica de negocios con otras dependencias.

Todav√≠a se pueden realizar pruebas unitarias sobre los controladores, haciendo mocks de todas las dependencias, pero hay dependencias que solo son visibles para tu sistema, estas √∫ltimas no deben ser reemplazadas por mocks y se verifican a trav√©s de las pruebas de integraci√≥n.

Por √∫ltimo el cuadrante de c√≥digo trivial no vale la pena ser probado, mientras que el del c√≥digo super complicado debe ser refactorizado para separarlo en modelos y controladores, como vimos en el <Link href="refactorizando-pruebas-unitarias-valiosas">cap√≠tulo anterior</Link>, donde hicimos un ejemplo de este refactor en video üìπ.

## Revisando la pir√°mide de pruebas

Es necesario tener un balance entre los 2 tipos de pruebas, ya que trabajar con dependencias out-of-process en la pruebas de integraci√≥n puede hacer las pruebas lentas y menos mantenibles, ya que:

* üíª Se crea la necesidad de mantener vivas o corriendo dichas dependencias.
* ü§° Como no se hacen menos mocks hay una alta cantidad de colaboradores.

Por otro lado las pruebas de integraci√≥n ejecutan una gran cantidad de c√≥digo, c√≥digo propio as√≠ como el c√≥digo de librer√≠as, por lo cual nos ofrecen una alta protecci√≥n contra regresiones.

La cantidad de pruebas de integraci√≥n y unitarias va a depender del tipo de proyecto, pero la regla general es que se busque cubrir la mayor parte de la l√≥gica de negocios con pruebas unitarias, y utilizar las pruebas de integraci√≥n para verificar un **happy path** y un **edge case** que no pueda ser verificado con las pruebas unitarias.

> **Happy path:** Es un flujo o camino de ejecuci√≥n exitoso de tu programa.

> **Edge case:** Es un camino de ejecuci√≥n que resulta en un error

Esto nos indica que el mayor peso lo tienen las pruebas unitarias, lo cual baja los costos de mantenimiento, pero siempre es necesario tener pruebas de integraci√≥n que aseguren el correcto funcionamiento del sistema como un todo.

![Pir√°mide de pruebas](/images/posts/piramide_pruebas.png)

La regla general se expresa con la pir√°mide de la imagen anterior, aunque como ya dije dependiendo el sistema, puede ser un sistema simple con muy poca l√≥gica de negocio, pero como ya expres√© siempre son necesarias las pruebas de integraci√≥n, quiz√° podamos terminar con la siguiente distribuci√≥n:

![Rectangulo de pruebas](/images/posts/rectangle_pruebas.png)

## Pruebas de integraci√≥n vs [Fail-fast](https://en.wikipedia.org/wiki/Fail-fast)

Las pruebas de integraci√≥n deben verificar al menos el happy path m√°s largo que abarque todas las interacciones con dependencias out-of-process, si no hay un camino que cubra todo, se pueden a√±adir m√°s pruebas.

El otro es un edge case que no sea cubierto por las pruebas unitarias, y en adici√≥n a eso (aqu√≠ es donde entra el versus) si se est√° aplicando el principio de fail-fast en nuestro sistema nos necesario probar esos casos ya que este principio asegura la ejecuci√≥n correcta y detecci√≥n de bugs de manera r√°pida , autom√°tica y desde el principio, por lo cual una prueba de integraci√≥n que busca respaldar lo mismo no tendr√≠a valor.

Ejemplo del uso de este principio:

```javascript
// Fast-fail principal
changeEmail(newEmail, company) {
    const message = this.canChangeEmail();
    if (message !== null) throw message;
    // Si falla aqui se detiene la ejecuci√≥n üö´ 
    ...
}
```

> **Fail-fast** principle: Se trata en el principio de detener la ejecuci√≥n de un programa tan pronto como ocurra un error inesperado, este principio se puede ver aplicado en los lenguajes que ocupan excepciones.

## ¬øQu√© dependencias out-of-process se deben probar directamente?

Como ya mencionamos hay las pruebas de integraci√≥n verifican como t√∫ sistemas se integra con dependencias out-of-process, y hay dos maneras de verificar est√©: utilizando las dependencias reales o sustituyendolas con mocks, a continuaci√≥n explico en que momento se debe hacer cada cosa.

Existen 2 tipos de dependencias:

* üöô **Dependencias manejadas**: son dependencias out-of-process de las cuales se tiene total control y solo son accesibles para tu aplicaci√≥n, un ejemplo com√∫n es la base de datos de tu aplicaci√≥n.
* üõ∞ **Dependencias no manejadas**: son dependencias out-of-process de las cuales no tienes el control al 100% , las interacciones con estas dependencias tienen un efecto secundario externo visible, por ejemplo la conexi√≥n a un SMTP para enviar un email.

Las dependencias manejadas son detalles de implementaci√≥n ya que contribuyen a la obtenci√≥n de un resultado dentro de tu aplicaci√≥n, mientras que las no manejadas son parte de un comportamiento observable, por lo cual aqui esta el secreto, las primeras las debemos probar directamente en las pruebas de integraci√≥n mientras que las segundas deben sustituirse por mocks para ser verificadas sin impactar elementos externos.

## Trabajando con ambos tipos de dependencias
A veces podemos encontrarnos con dependencias que sean de los 2 tipos al mismo tiempo, un ejemplo claro es una base de datos que inicialmente solo era accesible desde una aplicaci√≥n para al paso del tiempo m√°s aplicaciones se conecta a la misma base de datos, a√∫n puede conservar partes que son solo visibles para tu aplicaci√≥n pero otras ya no.

> ‚ö†Ô∏è El integrar sistemas a trav√©s de la base de datos, es una forma muy pobre de hacerlo porque acopla mucho los sistemas y complica desarrollos futuros, una mejor opci√≥n ser√≠a la creaci√≥n de un API.

**¬øPero qu√© pasa si ya tenemos esta situaci√≥n?** Lo que se debe hacer es probar directamente la dependencia cuando el comportamiento solo sea visible para tu aplicaci√≥n, pero si ese comportamiento ya tiene efecto o es visible para otros sistemas es momento de utilizar un mock.

![Dependencias que manejas y no manejas](/images/posts/both_manage_unmanage.png)
<small>Dependencias manejadas y no manejadas</small>


## Ahora un ejemplo de pruebas de integraci√≥n

En los 2 post anteriores les mostr√© una parte pr√°ctica en video, para esta ocasi√≥n volvemos a los ejemplos anterior

```javascript
// Imports
const UserFactory = require("./UserFactory");
const CompanyFactory = require("./CompanyFactory");
class UserController {
  constructor(database, messageBus) {
    this.database = database;
    this.messageBus = messageBus;
  }
  changeEmail(userId, newEmail) {
    const data = this.database.getUserById(userId);
    const user = UserFactory.create(data);
    const companyData = this.database.getCompany();
    const company = CompanyFactory.create(companyData);
    user.changeEmail(newEmail, company);
    this.database.saveCompany(company);
    this.database.saveUser(user);
    user.emailChangedEvents.forEach((event) => {
      this.messageBus.sendEmailChangedMessage(event.userId, event.email);
    });
  }
}
```

> El c√≥digo se ajusta un poco para poder ejemplificar la prueba de integraci√≥n de manera m√°s sencilla

En este ejemplo que es totalmente explicado: <Link href="/blog/posts/refactorizando-pruebas-unitarias-valiosas">Refactorizando para tener pruebas unitarias valiosas ‚≠ê</Link>, tenemos un peque√±o CRM que cumple con los siguientes puntos:

* Se puede cambiar el email de un usuario
* Si el email cambio se actualiza el n√∫mero de empleados si es que tiene el dominio de la compa√±√≠a o no.
* Si se presenta un cambio en el email esto es notificado al bus de mensajes.

Y espec√≠ficamente en el ejercicio del post pasado se hizo una refactorizaci√≥n para que la l√≥gica de negocio quedar√° en el modelo, y las operaciones se orquestaran desde un controlador, para ver el c√≥digo completo ir a el [repositorio](https://github.com/Andrew0914/refactoring_toward_valuble_tests) <GithubIcon/>.

![change email example](/images/posts/change_email_s.png)

1Ô∏è‚É£ Recordamos que necesitamos abarcar al menos 2 escenarios con nuestras pruebas de integraci√≥n, el primero es el happy path que interact√∫e con todas las dependencias out-of-process, el caso ser√≠a: **[escenario 1üé™] cuando cambies de un email corporativo a uno no corporativo, ya que eso actualiza el email, la n√∫mero de empleados y env√≠a una notificaci√≥n al bus de mensajes**.
 
El edge case que podemos evaluar es: **[escenario 2üé™] cuando no hay cambios en el email**, pero como en nuestro programa estamos aplicando el principio Fail-first no es necesario probar este caso.

2Ô∏è‚É£ Ahora vamos categorizar las dos dependencias out-of-process, la base de datos solo es observable para nuestra aplicaci√≥n por lo cual podemos verificar su estado de manera directa al ser una dependencia manejada, mientras que el bus mensajes lo que hace es entregar una notificaci√≥n a un sistema externo por lo cual es una dependencia no manejada que tendremos que verificar a trav√©s de un mock.

## ¬øQu√© hay de las pruebas end to end?

Las pruebas end to end corren deben ejecutarse un ambiente productivo o ya desplegado ya que son pruebas que se ejecutan desde el punto de vista del usuario final, recordemos que son las m√°s lentas y costas y el hacerlas est√° a discreci√≥n.

Ya que las pruebas de integraci√≥n est√°n probando directamente dependencias out-of-process y haciendo mocks de las dependencias que no son manejadas, ya nos ofrece un buen nivel de protecci√≥n, por lo cual no ser√≠a necesario hacer pruebas end-to-end, quiz√° si se desea se podr√≠a hacer una prueba que siga el camino m√°s largo de ejecuci√≥n despu√©s de un deploy solo para asegurar dicho deploy.

### Aplicando la primer prueba de integraci√≥n

```javascript
const { UserController } = require("../UserController");
const { Database } = require("../Database");
describe("Integration tests üõ∞", () => {
  it("Cambiando email corporativo a uno que no es corporativo", () => {
    // Arrange
    const database = new Database();
    const messageBusMock = {
      sendEmailChangedMessage: jest.fn((userId, newEmail) => {
        console.log("Message from mock ü§°", { userId, newEmail });
      })
    }
    const sut = new UserController(database, messageBusMock);
    // Act
    const result = sut.changeEmail(1, "codelapps@gmail.com");
    // Assert
    expect(result).toBe("ok");
    expect(database.getCompany()[1]).toBe(0);
    expect(database.getUserById(1)[1]).toBe("codelapps@gmail.com");
    expect(messageBusMock.sendEmailChangedMessage).toHaveBeenCalledWith(
      1,
      "codelapps@gmail.com"
    );
  });
});
```
En esta prueba estamos verificando todas las interacciones con dependencias out-of-process: la base de datos y el bus de mensajes, estamos utilizando directamente la dependencia al base de datos lo cual nos ofrece un alto grado de protecci√≥n contra regresiones y estamos utilizando un mock para el bus de mensajes.

## Usando interfaces para abstraer dependencias

Uno de los m√°s grandes malentendidos en el √°rea de pruebas unitarias es el uso de inerfaces, pero existen razones v√°lidas e inv√°lidas para usarlas.

Muchos desarrolladores utilizan interfaces para dependencias out-of-process incluso aunque solo tengan 1 implementaci√≥n, las razones por lo general son para bajar el nivel de acoplamiento y poder agregar funcionalidad nueva.

Adem√°s estar√≠amos rompiendo con el principio YAGNI(You aren‚Äôt gonna need it) asumiendo que vamos tener funcionalidad nueva, se pierde tiempo y se introduce m√°s c√≥digo.

Por √∫ltimo, todav√≠a hay un caso en el que si es v√°lido utilizar interfaces con solo una implementaci√≥n, y esto es para poder habilitar el uso de mocks de una manera sencilla,por lo tanto como vimos los mocks solo se le pueden hacer a las dependencias no manejadas, lo que nos da como conclusi√≥n que este tipo de dependencias out-of-process pueden implementar interfaces, en la s pruebas podemos utilizar dichas interfaces para hacer los mocks y no tocar la clase concreta y en el c√≥digo de producci√≥n utilizar la clase concreta.

## Mejores pr√°cticas para pruebas de integraci√≥n

Existen 3 pr√°cticas generales para ayudar a sacar el m√°ximo provecho a tus pruebas de integraci√≥n:

* üöÄ Hacer expl√≠citos los l√≠mites de nuestro dominio
* üçû Reducir el n√∫mero de capas en la aplicaci√≥n
* üöÆ Eliminar dependencias
El implementarlas no solo mejora tus pruebas, tambi√©n tu base de c√≥digo.

üöÄ Siempre trate de tener bien ubicado cual es y donde est√°n tus modelos de domino.

> El **modelo de dominio** es el conjunto de clases o m√≥dulos que contienen la l√≥gica principal que resuelven el problema para lo cual est√° hecho el proyecto

Si nosotros tenemos de manera expl√≠cita los l√≠mites del modelo y los controladores, podemos determinar r√°pidamente sobre que hacer pruebas unitarias y sobre que hacer pruebas de integraci√≥n, estos l√≠mites pueden ser marcados con namespaces o una estructura de carpetas adecuada por ejemplo.

üçû Reducir el n√∫mero de capas de nuestro sistema es importante, un sistema con un n√∫mero excesivo de capas vuelve dif√≠cil distinguir los l√≠mites que hablamos en el punto anterior, hace complejo la abstracci√≥n del c√≥digo para poder ser probado, es decir, no sabes que tomar como objetivo para las pruebas unitarias o de integraci√≥n y crea una tendencia o necesidad de probar capa por capa generando una p√©rdida de protecci√≥n contra regresiones.

![capas](/images/posts/capas_1.png)

Lo mejor es tratar de tener la menor cantidad de capas posibles bien definidas.

üöÆ Por √∫ltimo est√° el tema de dependencias circulares, que es cuando 2 o m√°s m√≥dulos dependen una de la otra de manera directa o indirecta, ejemplo:

```javascript
class CheckoutService {
  checkout(orderId) {
    const reportService = new ReportService();
    reportService.generate(orderId, this);
    // code ...    
  }
}
class ReportService {
  generate(orderId, checkoutService) {
    // llamadas checkoutService
  }
}
```
Con este tipo de dependencias incrementamos muchismo la carga cognitiva de entender el c√≥digo, pero tambi√©n vuelve complejo utilizar o hacer mocks de esas clases en nuestras pruebas.

## √öltimas recomendaciones

En general una prueba de integraci√≥n tambi√©n se puede dividir en 3 secciones **Arrange-Act-Assert**, tambi√©n suele ser un mal olor el tener m√°s de una secci√≥n de estas dentro de la misma prueba ya que puede indicar la necesidad de hacer m√°s de una prueba, sin embargo hay casos particulares en las pruebas de integraci√≥n ya que se necesita verificar las dependencias out-of-process y muchas de estas pueden ser dif√≠ciles o costosas de manejar , por ejemplo tener un n√∫mero limitado de accesos a un API, en este caso es posible tener m√°s de una de estas secciones para reducir la cantidad de llamados.

Como √∫ltimo agregado, el libro habla sobre sistemas de logging pero me parece en particular que es especificar mucho sobre este tipo de sistemas, la ense√±anza general es que si el log que mandas es parte del proceso de desarrollo/debug este debe ser considerado como un detalle de implementaci√≥n, pero si el log es de utilidad para algo o alguien externo se vuelve parte de un comportamiento observable que debe ser verificado.

Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro:

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).

