# Mocks y fragilidad en las pruebas

A lo largo de este post conoceremos, m√°s a detalle los mocks y los otros tipos de test doubles, tambi√©n veremos como los mocks est√°n relacionados con la fragilidad en las pruebas.

Como ya vimos en el primer post de esta serie: <Link href="meta-pruebas-unitarias">La meta de las pruebas unitarias</Link>, existen dos corrientes o escuelas para crear pruebas unitarias, en resumen ambas escuelas difieren por la forma en que se deben aislar las pruebas, ambas a trav√©s de test doubles que eliminan las dependencias.

En muchos casos se dice que el uso de mocks solo hace m√°s fr√°giles tus pruebas, pero esto no siempre es as√≠, muchas veces tambi√©n el uso de mocks es preferible.

### Diferencia entre mocks y stubs
Hasta ahora a lo largo de los posts hemos mencionado los mocks y los tests doubles en general, un mock es un tipo de test double, pero existen otros, por ejemplo: **stub**.

Test double es un t√©rmino general que proviene de la noci√≥n de los dobles de prueba o de acci√≥n en las pel√≠culas, hay varios tipos.

En general, uno de los usos m√°s comunes es facilitar las pruebas, nos ayudan a sustituir las dependencias, evitando as√≠ la complejidad que pueden tener las reales y principalmente poder aislar lo que estamos probando.

De acuerdo a [Gerard Meszaros](https://g.co/kgs/bn6g4G) existen 5 variaciones de test doubles:

* ü§° Dummy
* ü§ñ Stub
* üë∫ Fake
* üòé Spy
* üëæ Moc

Pero podemos categorizarlos en 2 grandes grupos:

![Clasificaci√≥n de los test doubles](/images/posts/test_doubles_categories.png)
<small>Clasificaci√≥n de los test doubles</small>

La diferencia princi√°l entre los mocks y los stubs es la siguiente:

* ü§ñ Stub: Ayuda simular interacciones de entrada, es decir, llamadas que el SUT hace a sus dependencias para obtener informaci√≥n de entrada para realizar alguna operaci√≥n.
* üëæ Mock: Sirve para simular y analizar interacciones de salida, es decir, son llamadas que el SUT hace a sus dependencias para que cambien su estado, es decir devienen en un side effect.

Para que se usa un mock vs un stub
![¬øComo usar los mocks vs stubs?](/images/posts/mocks_vs_stubs.png)
<small>¬øComo usar los mocks vs stubs?</small>

Internamente dentro de cada una de las 2 grandes categor√≠as que mencionamos, empezando por los mocks, a diferencia de lo que dice el libro, yo pienso que la diferencia entre un mock y un spy es que el mock tu puedes construir la forma de emular el comportamiento mientras que un spy est√° al pendiente o copia como tal el comportamiento de la dependencia real.

En cuanto a los stubs, dummies y fakes la √∫nica diferencia son detalles de implementaci√≥n y el nivel de complejidad con el que se construye, siendo el dummy el m√°s simple ya que puede ser desde un dato en duro como una cadena de texto hasta un objeto vac√≠o sin comportamiento solo para satisfacer la entrada requerida.

Un fake por otro lado es el siguiente nivel de complejidad y se usan para remplazar dependencias que se generan durante la ejecuci√≥n.

Por √∫ltimo un stub suele ser el m√°s complejo ya que puede ser configurado para agregarle comportamientos que satisfaga distintos escenarios.

### Mock(el test double) vs Mock(la herramienta)

El t√©rmino mock se ha sobrecargado mucho, tanto as√≠ que suele ser utilizado como sin√≥nimo de test double, sin embargo este solo es un tipo de test double, asimismo, en muchos frameworks nos encontraremos que las herramientas para crear test doubles contienen la palabra ‚Äúmock‚Äù pero no siempre son utilizadas para crear mocks como tal, si no para crear stubs tambi√©n.

Ejemplos:

```java
// MOCK
public class Tests {
    @Test
    public void an_example_test(){
        // Arrange
        Database database= mock(Database.class); // mock la herramienta üî®
        // database es un mock creado con dicha herramienta üëæ
        when(database.saveUser("user@test.com","Jhon"))
        .thenReturn(new User(1,"user@test.com","Jhon"))
        UserController sut = new UserController(database);
        //  Act
       sut.register("user@test.com","Jhon");
        // Assert
        verify(database, times(1)).saveUser()
    }

}
```

```java
// STUB
public class Tests {
    @Test
    public void an_example_test(){
        // Arrange
        Country[] countries = new Country[1];
        countries[0] = new Country("Mexico")
        CountriesApi api = mock(CountriesApi.class); // mock la herramienta üî®
        // un stub ü§ñ generado a trav√©s de la herramienta mock 
        when(api.getAvailables()).thenReturn(countries) 
        UserController sut = new UserController(api);
        //  Act
        sut.doSomething()
        // Assert
        assertEquals();// assert something
    }

}
```
### No verifiques tus pruebas a trav√©s de los stubs

Como ya mencionamos, un mock nos sirve para emular y examinar interacciones de salida, que generalmente producen side effects, los cuales pueden ser examinados como el resultado final.

Mientras que un stub es utilizado solo para satisfacer informaci√≥n o datos de entrada que necesita el SUT para producir un resultado, es decir los stubs no forman parte del resultado final.

En otras palabras podemos ver a los stubs como detalles de implementaci√≥n, ya que no son parte del resultado final, recordando uno de <Link href="meta-pruebas-unitarias"> los 4 pilares de las pruebas unitarias</Link> que es la resistencia al refactoring, no debemos acoplar las pruebas a detalles de implementaci√≥n, si no verificar el resultado final.:

> Para satisfacer el pilar de **resistencia al refactoring**, no debemos acoplar las pruebas a detalles de implementaci√≥n, si no verificar el resultado final.

El verificar las pruebas con los stubs incurre en un antipatr√≥n bien conocido, adem√°s cuando construimos un stub nosotros conocemos que informaci√≥n ser√° devuelta en que escenario, as√≠ que verificar una prueba con un stub solo caer√≠a en una sobre especificaci√≥n.

```java
// stub ü§ñ
public class Tests {
    @Test
    public void an_example_test(){
        // Arrange
        Country[] countries = new Country[1];
        countries[0] = new Country("Mexico")
        CountriesApi api = mock(CountriesApi.class); 
        when(api.getAvailables()).thenReturn(countries) 
        UserController sut = new UserController(api);
        //  Act
        sut.doSomething()
        // Assert ‚ùå No verificar con stubs | üòñ sobre especificaci√≥n
        verify(sut, times(1)).getAvailables();
        assertEquals(sut.api.getAvailables()[0], countries[0])
    }
}
```

### Usando mocks y stubs juntos

Muchas veces podemos generar un test double que cumpla la funci√≥n de un mock y un stub al mismo, para fines pr√°cticos y por complejidad se determina que es un mock, veamos un caso de pr√°ctico:

```java
public class Tests {
  @Test
  public void register_seat_if_is_available(){
    // Arrange
    Seats seats= mock(Seats.class);
    
    // ü§ñ Stub
    when(seats.isAvailable(1))
      .thenReturn(true);
    // üëæ Mock
    when(seats.register("Jhon", 1))
    .thenReturn(true);
    SeatsController sut = new SeatsController(database);
    //  Act
    sut.register("Jhon",1);
    // Assert
    verify(seats, times(1)).register();
  }
}
```

En el c√≥digo anterior vemos c√≥mo se utiliza un mock de la clase Seats como stub para satisfacer que un asiento est√© disponible y un mock para verificar el registro del asiento.

### ¬øC√≥mo se relacionan los mocks y stubs con el patr√≥n de commands and queries?

Existe otra forma para determinar cu√°ndo podemos realizar un mock y cuando se debe realizar un stub, en realidad esto empata con un patr√≥n bien conocido llamado [commands & queries](https://martinfowler.com/bliki/CQRS.html).

En un resumen muy breve, este patr√≥n trata de que los m√©todos u operaciones que tienen un efecto secundario o side effect sobre algo son conocidos como comandos mientras que los m√©todos que solo devuelven informaci√≥n a trav√©s de un c√°lculo o no sin generar un side effect, son queries.

Es un concepto tambi√©n utilizado en las t√©cnicas de refactor donde debemos tener bien separados las acciones que representan un comando y las que representan un querie, cada una en su propio m√©todo.

Lo anterior ayuda a una mejor base de c√≥digo, facilidad de crear pruebas unitarias y para este caso la facilidad de seleccionar el test double correcto.

![Tests doubles para command - query](/images/posts/which_test_double_commandquery.png)

### Comportamiento observable vs detalles de implemenaci√≥n

Recordando el post de <Link href="meta-pruebas-unitarias">los 4 pilares de una prueba unitaria</Link>, vimos que la resistencia al refactoring es un pilar que se tiene o no se tiene, y que es este el que nos ayuda a evitar la fragilidad en las pruebas.

La forma de tener esta resistencia al refactoring es evitar la mayor cantidad de falsos positivos, es decir, concentrarnos en el que y no en el c√≥mo, dicho de una forma m√°s concreta, no debemos verificar nuestras pruebas a trav√©s de detalles de implementaci√≥n si no con el resultado final.

### El API p√∫blica debe exponer el comportamiento observable solamente

Todo software puede ser categorizado en 2 dimensiones:

* Api publica vs API privada
* Comportamiento observable vs detalles de implementaci√≥n

Cada una de las categor√≠as son mutuamente excluyentes, es decir, un m√©todo p√∫blico no puede ser privado y viceversa, as√≠ como tambi√©n el c√≥digo puede ser un detalle interno de implementaci√≥n o parte del comportamiento observable pero no ambos.

Muchos lenguajes de programaci√≥n, de los m√°s comunes los orientados a objetos, tienen mecanismos para poder hacer esta separaci√≥n de categor√≠as adecuadamente, como por ejemplo, modificadores de acceso : `public` y `private`.

Public por ejemplo, se utiliza para denotar que el m√©todo o miembro de un m√≥dulo o clase est√° expuesto para que lo utilice un cliente, es decir se puede acceder a el, mientras que private denota que es un m√©todo o miembro que solo puede ser accedido internamente en la clase o m√≥dulo, quedando oculto para clientes externos.

### ¬øC√≥mo podemos distinguir que c√≥digo forma parte del comportamiento observable y que es un detalle de implementaci√≥n?

Un parte de c√≥digo forma parte del comportamiento observable cuando:

* Expone una operaci√≥n que ayuda al cliente a llegar a una de sus metas, puede o no incurrir en un side effect.
* Expone estado que ayuda al cliente a llegar a una de sus metas.

Cualquier otra parte de c√≥digo que no cumpla con esto, es un detalle de implementaci√≥n, que algo sea parte del comportamiento observable depende de qui√©n sea el cliente y que tenga al menos una conexi√≥n directa con una de sus metas.

¬øA qu√© nos referimos como el cliente? Puede referir a muchas cosas dependiendo donde reside el c√≥digo, puede ser desde un miembro del mismo sistema, es decir una clase que consuma un m√©todo de otra clase, una aplicaci√≥n externa o hasta la interfaz de usuario.

Idealmente un sistema con un API bien dise√±ada, alinea su API p√∫blica solamente a su comportamiento observable, dejando los detalles de implementaci√≥n ocultos a los ojos del cliente.

![API observable behaviour ](/images/posts/comportamiento_observable_api1.png)

Por otro lado cuando un api no est√° bien dise√±ada, suele filtrar detalles de implementaci√≥n a trav√©s del AP p√∫blica.

![API observable behaviour ](/images/posts/comportamiento_observable_api2.png)

### Exponiendo detalles de implementaci√≥n üò±
Expliquemos cu√°l ser√≠a una forma de filtrar detalles de implementaci√≥n al api p√∫blica:



```java
// Book.java üìÇ
public class Book {
    
    public int id;
    public Date publicationDate;
    public int category;

    public Book(int id, Date publicationDate){
        this.id = id;
        this.publicationDate = publicationDate;
    }

    public int categorize(Date publicationDate, Date lastCentury){ ‚ùå
        return this.publicationDate.after(lastCentury) ? 0 : 1;
    }
}

```

```java	
// BookController.java üìÇ
public class BookController {
    public void saveBook(int bookId, Date publicationDate){
        Book book = new Book(bookId,publicationDate);
        Date lastCentury = new Date(1900, 1, 1);
        book.category = book.categorize(publicationDate, lastCentury); ‚ùå
        save(book);
    }
}
```

En el ejemplo anterior vemos c√≥mo BookController es cliente de la clase Book, ya que est√° consumiendo elementos expuestos por esta misma, vemos que se guarda un libro con su id, su fecha de publicaci√≥n y su categor√≠a.

Tambi√©n vemos que para guardar el libro se calcula su categor√≠a, pero hacerlo de esta manera puede generar inconsistencias, ya que si nosotros guardamos sin calcular esta categor√≠a, java por defecto pondr√° la categor√≠a en 0 [(defaults de datos primitivos en java)](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html) sin importar si es correcto.

Lo anterior demuestra que el c√°lculo de la categor√≠a deber√≠a ser un detalle de implementaci√≥n oculto para el cliente, a trav√©s de una buena encapsulaci√≥n, asegurandonos no caer en una invariaci√≥n.

Veamos un mejor enfoque de esto:

```java	
// Book.java üìÇ
public class Book {
    
    private int id;
    private Date publicationDate;
    private int category;

    public Book(int id, Date publicationDate){
        this.id = id;
        this.publicationDate = publicationDate;
        this.category = this.categorize(publicationDate) ‚úÖ
    }

    private int categorize(Date publicationDate){
        Date lastCentury = new Date(1900, 1, 1);
        return this.publicationDate.after(lastCentury) ? 0 : 1;
    }

    // getter methods ...
}
```

```java
// BookController.java üìÇ
public class BookController {
    public void saveBook(int bookId, Date publicationDate){
        Book book = new Book(bookId,publicationDate); ‚úÖ
        save(book);
    }
}

```
En el anterior ejemplo vemos que el c√°lculo de la categor√≠a ahora es invisible para el cliente y siempre ser√° calculada correctamente.

Un API bien dise√±ada esta directamente relacionada con la [encapsulaci√≥n](https://www.tutorialspoint.com/java/java_encapsulation.htm#:~:text=Encapsulation%20in%20Java%20is%20a,methods%20of%20their%20current%20class.), recordemos que la encapsulaci√≥n es la forma de protegernos de posibles inconsistencias o invariaciones.

La encapsulaci√≥n tambi√©n nos va a ayudar con la complejidad de nuestro sistema, si nosotros solo exponemos lo necesario para el cliente, sin filtrar detalles de implementaci√≥n, ser√° m√°s f√°cil de entender qu√© es lo que hace nuestro m√≥dulo.

Con lo anterior, en relaci√≥n directa, nos ayuda con la mantenibilidad de nuestros sistema y nos facilita hacer pruebas unitarias, ya que sabr√≠amos directamente que estamos probando el comportamiento observable solamente.

### La relaci√≥n de los mocks y la fragilidad en las pruebas

Para finalizar este post, quiero resaltar que el libro contiene un par de temas mas sobre la relaci√≥n de los mocks y la fragilidad en las pruebas, explica 3 cosas principalmente:

Habla sobre la arquitectura hexagonal, imaginando un hex√°gono, la parte interna o n√∫cleo del hex√°gono representa la capa de dominio o l√≥gica de negocio, y la parte externa representa una capa de aplicaci√≥n que sirve para alimentar la capa de dominio y comunicarse con el mundo exterior.

La capa de negocio es la encargada de realizar el conjunto de operaciones que resuelve el problema para la cual esta hecha tu aplicaci√≥n, mientras que la capa de aplicaci√≥n expone como salidas estos resultados.

La capa de aplicaci√≥n se comunica con el mundo externo con otros sistema o aplicaciones que pueden ser representados tambi√©n con hex√°gonos.

![arquitectura hexagona](/images/posts/hexagonal_architecture.png)
<small>Arquitectura hexagonal</small>


El concepto de este tipo de arquitectura hace una demostraci√≥n de c√≥mo se comunica una aplicaci√≥n:

* 1Ô∏è‚É£ Internamente entre los elementos de la capa de negocio, estos son meros detalles de implementaci√≥n y operaciones.
* 2Ô∏è‚É£ De la capa de negocios a la capa de aplicaci√≥n, se entregan resultados, los cuales son comportamientos observados
* 3Ô∏è‚É£ De la capa de aplicaci√≥n hacia fuera, ya es el resultado final el que se comunica a otros sistema u otras aplicaciones

![communication in hexagonal architecture](/images/posts/hexagonal_architecture_communication.png)
<small>Comucaci√≥n en la arquitectura hexagonal </small>

En el tipo 1Ô∏è‚É£ como ya hemos estudiado, los detalles de implementaci√≥n no deben ser candidatos a ser mocks ni a tomarlos como base para la verificaci√≥n de las pruebas.

En el tipo 2Ô∏è‚É£ son justamente las interacciones que deben se verificadas en nuestras pruebas unitarias.

Por √∫ltimo en el tipo 3Ô∏è‚É£ estan las interacciones candidatas a que se les sustituya por un mock, ya que tienen un side effect y forman parte del comportamiento observado, ya que estan ayudando a llegar a una de sus metas a otros clientes.

Como nota final recordemos que para evitar fragilidad en las pruebas, debemos verificar el comportamiento observado, las interacciones de salida, el resultado final que ayuda a llegar a una de sus metas a un cliente.

Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro: 

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).
