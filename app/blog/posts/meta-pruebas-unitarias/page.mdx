# La meta de las pruebas unitarias
## Unit testing, principios, pr√°cticas y patrones | Resumen


### El estado actual del unit testing.

Por mucho tiempo desde que se impulso la pr√°ctica de hacer pruebas unitarias al software, la pregunta era **¬øDebemos hacer pruebas unitarias?.**

Sin embargo este empuje tuvo mucho √©xito y ahora todo programador que se diga ser profesional o todo aquel que desee serlo debe conocer y practicar el hacer pruebas unitarias a su c√≥digo, as√≠ mismo para las compa√±√≠as que hacen productos profesionales se volvi√≥ obligatorio realizar pruebas unitarias, lo cual convierte esa pregunta inicial a **¬øC√≥mo hacer una buena prueba unitaria?**

### ¬øCu√°l es el objetivo de las pruebas unitarias?

Si bien se dice que hacer pruebas unitarias a tu software mejoran el dise√±o del mismo, este solo es un buen efecto secundario, realmente **lo que se busca con las pruebas unitarias es habilitar el crecimiento sostenible de un proyecto de software.**

Por ejemplo: agregar una nueva funcionalidad, o corregir alg√∫n bug con la seguridad de que no romper√°s el resto de cosas en tu sistema.

Estas posibles rupturas son conocidas como ‚Äúregresiones‚Äú, las pruebas unitarias sirven como una red de seguridad y previenen la tendencia del software a deteriorarse.

El no hacer pruebas unitarias provocar√° que el progreso de tu sistema no sea sostenible, mientras que con pruebas unitarias podemos generar un progreso certero, lo mismo sucede con malas pruebas unitarias, aunque de inicio si disminuyen la velocidad en que tu software se deteriora, al final se comportan como si no realizaras pruebas ya que no respaldan adecuadamente tu sistema.

![Salun de tu sistema con pruebas unitarias](/images/posts/system_progress.png)

### Las m√©tricas de cobertura como medida de una buena calidad de suite de pruebas unitarias

Existen dos m√©tricas de cobertura populares que son el ‚Äúcode coverage‚Äù y el ‚Äúbranch coverage‚Äù, estas m√©tricas nos indican que tanto de nuestra base c√≥digo se esta ejecutando a trav√©s de las pruebas; la creencia general es que una mayor cobertura es mejor y que estamos teniendo un buen nivel de pruebas unitarias, pero la realidad no es tan simple.

El ‚Äúcode coverage‚Äù o ‚Äútest coverage‚Äù es el m√°s popular de los 2, y se determina de la siguiente manera:

**code coverage** = executed lines / total lines

Ejemplo

```java
/* Test code */
public void test(){
    boolean result = isNameLong("abc");
    assertFalse(result); // esta ejecutando 4/5 (la 8,9,11 y 12) lineas = 80%
}
/*Source code*/
public static boolean isNameLong(String name){
    if(name.length > 5) //covered by test
        return true; // no covered
    return false; //covered by test
}
```

Podemos darnos cuenta que se est√°n ejecutando 4/5 (la 8,9,11 y 12) lineas = 80% de l√≠neas con la prueba, pero si nosotros refactorizamos el m√©todo bajo prueba algo as√≠:

```java
/*Source code*/
public static boolean isNameLong(String name){
    return name.length > 5 //covered by test
}
```

podr√≠amos estar cubriendo 3/3 lineas teniendo as√≠ un 100% de code coverage.

Por otro lado el ‚Äúbranch coverage‚Äù en lugar de medir la cantidad plana total de lineas ejecutadas, mide la cantidad de ramas que toca en funcion de las estructuras de control como un if/switch.

**branch coverage** = ramas tocadas / total de ramas

```java
/*Source code*/
public static boolean isNameLong(String name){
    return name.length > 5
}

/* Test code */
public void test(){
    boolean result = isNameLong("abc");
    assertFalse(result);
}
```
En el siguiente diagrama vemos los dos posibles caminos que puede tomar nuestro c√≥digo bajo prueba:

![Code branches](/images/posts/code_branches.png)

Vemos que hay dos posibilidades de ejecuci√≥n (2 caminos √≥ 2 ramas), y en nuestra prueba estamos pasando a trav√©s de 1 por lo cual estamos teniendo 1/2 ramas tocas = **50% de branch coverage**.

El problema de tomar las m√©tricas de cobertura como medidas de calidad es que los n√∫meros o porcentajes arrojados pueden ser enga√±osos, los ejemplos anteriores son simples, pero si nosotros tuvi√©ramos algo as√≠:

```java
public static boolean isNameLong(String name){
    boolean wasNameLong = false
    if(name.length > 5) {
        wasNameLong = true; // no guaranteed
        return true; 
    }
    return false; 
}
 
/* Test code */
public void test(){
    boolean result = isNameLong("abcdef");
    assertFalse(result);
}
```
Vemos que aunque 6/7= 85% l√≠neas est√°n siendo ejecutadas, solamente se esta probando impl√≠citamente la l√≠nea con el **return**, no garantizando que por ejemplo wasNameLong tenga el valor correcto, lo mismo para la cantidad de ramas tocadas que en este ejemplo tambi√©n es 50% ya que solo esta probando cuando la condici√≥n del if es verdadera.

Podemos darnos cuenta que si bien son √∫tiles estas m√©tricas **suelen ser un excelente indicador negativo pero un mal indicador positivo de la calidad de tus pruebas,** es decir, si los porcentajes son bajos si puede ser indicador de que tienes muchas parte de tu c√≥digo sin probar, pero por el contrario el tener un alto porcentaje no indica que tienes una buena suite de pruebas.

Por eso es importante no tener como objetivo un determinado porcentaje de cobertura si no mas bien una buena suite de pruebas que aporten valor a tu sistema y lo respalden de manera adecuada, verificando las partes m√°s importantes o cr√≠ticas de tu software.

### ¬øQu√© hace una buena suite de pruebas unitarias?

* Hacer pruebas tiene que ser parte del ciclo de desarrollo.
* La suite de pruebas debe tener como objetivo las partes mas importantes o cr√≠ticas de tu sistema.
* Debe proveer el m√°ximo valor con el m√≠nimo costo de mantenimiento.

En general se tiene que estar realizando pruebas constantemente como parte del ciclo de desarrollo a las partes m√°s cr√≠ticas de nuestro sistema a medida que las vamos construyendo, las partes cr√≠ticas suele ser la l√≥gica de negocio, dejando de lado c√≥digo de infraestructura, condigo o dependencias externas y c√≥digo de integraci√≥n, reconociendo si la prueba realmente nos aporta valor o respalda adecuadamente lo que estamos verificando.

Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro: 

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).
