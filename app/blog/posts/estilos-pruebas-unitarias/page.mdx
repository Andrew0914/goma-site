# Estilos de pruebas unitarias
## Unit testing, principios, pr√°cticas y patrones | Resumen


Esta vez conoceremos 3 estilos de realizar pruebas unitarias: **output-based, state-based y communication-based**, es decir, estilo basado en las salidas o resultado, el estilo basado en el estado y el estilo basado en las comunicaciones.

El estilo que ofrece la mayor calidad de pruebas es el basado en salidas, aunque desafortunadamente no puede ser utilizado absolutamente en todos lados, ya que este estilo depende de que lo que se est√© probando este escrito en manera puramente funcional.

Debemos apoyarnos tambi√©n de los otros estilos, sin embargo es posible orientar y convertir la mayor cantidad de c√≥digo de nuestra aplicaci√≥n a [programaci√≥n funcional](https://es.wikipedia.org/wiki/Programaci%C3%B3n_funcional) para intentar mantener nuestras pruebas en el primer estilo.

A continuaci√≥n explicar√© m√°s a detalle todo lo anterior.

### Estilo output-based o estilo basado en resultados

El primero de los 3 estilos, en este estilo el sistema bajo pruebas es alimentado por una o m√°s entradas conocidas y se verifica a trav√©s de la √∫nica salida que produce.

Este estilo solo aplica para cuando el SUT no cambia el estado interno o global de nada, simplemente la √∫nica salida generada es a trav√©s de su valor de retorno.


```java
// DiscountCalculator.java üìÇ

public class DiscountCalculator{
  public double wholesaleDiscount(Product[] products){
    double disccount = products.length * 0.01;
    return Math.min(disccount, 0.05);
  }
}

// Product.java üìÇ
public class Product {
  private String name;
  public Product(String name){
    this.name = name;
  }
}
```

Este es un ejemplo bastante sencillo, el m√©todo **wholesaleDiscount** de la clase **DisccountCalculator** recibe una lista de objetos de la clase **Product**, y multiplica la cantidad de esos productos en la lista por 1% para calcular el descuento, con un descuento m√°ximo de 5% el cual es devuelto.

Y ya est√° no hay m√°s, no hay efectos secundarios, no se almacen√≥ nada en base de datos , el file system o algo por el estilo, aplicando una prueba unitaria quedar√≠a como sigue:

```java
@Test
public void disccount_of_product_list_with_max_5_percent(){
  // Arrange
  Product[] products = {
    new Product("soap"),
    new Product("jam"),
    new Product("water"),
    new Product("soda"),
    new Product("bread"),
    new Product("toast")
  };
  
  DisccountCalculator calculator = new DiscountCalculator();
  // Act
  double disccount = calculator.wholesaleDiscount(products);
  // Assert
  assertEquals(disccount, 0.05);
}
```

Este estilo tambi√©n es conocido como **funcional**, y tiene sus ra√≠ces en la programaci√≥n funcional, que busca o prefiere tener c√≥digo sin efectos secundarios, de nuevo reitero este estilo debe ser el preferido, sin embargo no siempre va a ser posible aplicarlo.

### Estilo state-based o estilo basado en estado

Este estilo busca verificar el estado del sistema despu√©s de haber realizado una operaci√≥n completa.

El estado que verifica puede ser del SUT mismo, el estado global, el de uno de los colaboradores o incluso el de dependencias out-of-process como la base de datos o el sistema de archivos.

Ejemplo:

```java
// course.java üìÇ
public class Course {
  
  private ArrayList<Student> students = new ArrayList<Student>();
  public void addStudent(Student student){
    this.students.add(student)
  }
  public ArrayList<Student> getStudents(){
    return this.students
  }
}

@Test
public void add_student_to_a_course(){
  // Arrange
  Course course = new Course();
  Student student = new Student("Andrew")
  // Act
  course.addStudent(student)
  // Assert 
  assertEquals(course.getStudents().size(), 1)
}
```


En el ejemplo anterior vemos que se est√° verificando a trav√©s del estado en el que se encuentra un atributo de la clase Course y utilizando uno de sus colaboradores, el m√©todo que se prueba no retorna nada, pero s√≠ tiene una salida reflejada en el estado de la clase.

### Estilo communication-based o estilo basado en comunicaciones

El √∫ltimo de los 3 estilos, es es el estilo basado en comunicaciones que verifica las pruebas a trav√©s de las interacciones de salida entre el SUT y sus colobadores.

Para verificar las interacciones de salida, recordemos que se utilizan los mocks, como dato adicional, el enfoque tradicional prefiere el estilo basado en estado que el de comunicaciones y viceversa la escuela de Londres.
```java
@Test
  public void save_user_with_email(){
      // Arrange
      User user = new User("ccodelapps@gmail.com");
      Database database = mock(Database.class); 
      when(database.save(user)).thenReturn(true) 
      UserController sut = new UserController(api);
      //  Act
      sut.save(user)
      // Assert 
      verify(database, times(1)).save();
  }
```

En el ejemplo anterior se verifica la interacci√≥n de salida que tiene el sistema bajo pruebas hacia la base de datos, se est√° comunicando y se verifica que se haya efectuado dicha comunicaci√≥n.

### Comparando los 3 estilos

#### Con el pilar de protecci√≥n contra regresiones y la r√°pida retroalimentaci√≥n

Esta es la comparaci√≥n m√°s simple por que en realidad ninguno de los 3 estilos provee una ventaja sobre otro para estos 2 pilares, recordemos que para tener el pilar de protecci√≥n contra las regresiones necesitamos lo siguiente:

* üìù La cantidad de c√≥digo que se ejecuta durante la prueba
* üïπ La complejidad del c√≥digo que se est√° ejecutando
* üëì La significancia del c√≥digo ejecutado

En general tu puedes ejecutar tanto o tan poco c√≥digo tu desees en tus pruebas ,lo mismo para la complejidad y la significancia, solo existe una diferencia en el estilo basado en comunicaciones, si abusas mucho de este estilo y por ende de los mocks, podrias terminar com pruebas superficiales.

Respecto a la r√°pida retroalimentaci√≥n, de igual manera no depende de un estilo en particular, depender√° en si que aisles tus pruebas de dependencias out-of-process.

#### Con el pilar de resistencia al refactoring
En general las pruebas deben ser capaces de soportar si los detalles de implementaci√≥n cambian, por tanto las pruebas no deben estar acopladas a estos, sino a los resultados.

Dicho lo anterior, nos damos cuenta que el primer estilo output-based o estilo basado en salidas es el que mejor resistencia al refactoring presenta ‚úÖ, ya que este tipo de pruebas se basa en los resultados.

El estilo basado en estado, es un poco mas propenso a tener falsos positivos, por tanto es menos resistente al refactoring, ya que se verifican elementos de la clase o colaboradores, entre m√°s amplia o profunda se la verificaci√≥n pas probabilidad hay de que se caigan en verificar detalles de implementaci√≥n üòí.

Por √∫ltimo el estilo basado en comunicaciones, puede caer como ya dijimos en pruebas superficiales o fr√°giles si se abusa de los mocks, recordemos que los mocks solo deben ser para dependencias de fuera de la aplicaci√≥n y que tengan un efecto secundario, por tanto este estilo es el m√°s propenso a esto.

#### Con el pilar de mantenibilidad
El pilar de la mantenibilidad est√° altamente relacionado con los estilos de pruebas unitarias, pero a diferencia de la resistencia al refactoring no se puede hacer mucho al respecto, recordemos que las pruebas son mantenibles en medida de:

* üò± Que tan dificil es entender las pruebas
* ‚úà Que tan dificil es ejecutar las pruebas, si hay que levantar instancias de alguna otra cosa

Generalmente las pruebas output-based son cortas y concisas, lo cual las vuelve altamente mantenibles, y dado que este tipo de pruebas no genera efectos secundarios o de estado no se conecta a dependencias out-of-process lo cual las vuelve m√°s r√°pidas tambi√©n.

Para las pruebas basadas en estado suele tomar m√°s l√≠neas de c√≥digo verificar las, ya que las pruebas basadas en este y el comportamiento que se est√© probando puede generar m√°s de un efecto secundario que se puede generar, esto se vuelve peor si no se encuentra bien encapsulado el comportamiento, as√≠ que son un poco menos mantenibles.

De nuevo (parece que es el peor , pero todav√≠a puede usarse si se lo hace adecuadamente) es el estilo basado en comunicaciones, ya que debido al uso de mocks, dependiendo de qu√© complejos sean, si los combinamos con stubs y dem√°s cosas, hace las pruebas mas grandes y m√°s complejas de entender.

### Conclusiones de la comparaci√≥n
Hemos comparado cada uno de los estilos y su desempe√±o para cada uno de los 4 pilares de las pruebas unitarias, vimos que para la protecci√≥n contra regresiones y la r√°pida retroalimentaci√≥n califican igual.

En cuanto al pilar de resistencia la refactoring, el estilo **output-based** raramente va a estar acoplado a los detalles de implementaci√≥n, las pruebas de este estilo son concisas y muy raramente van a utilizar dependencias **out-of-process**, por lo cual son muy r√°pidas de ejecutar.

El estilo **stated-based** y **communication-based**, suelen ser m√°s propensas a caer en detalles de implementaci√≥n y tambi√©n suelen ser pruebas grandes con un costo m√°s alto de mantenimiento.

Una vez entendido lo anterior, nos damos cuenta que siempre es preferible utilizar el estilo basado en salidas o **output-based**, sobre los dem√°s, desafortunadamente para ello se necesita que lo que se prueba este escrito de manera funcional, pero esto no siempre es as√≠, sin embargo s√≠ podemos aplicar ciertas t√©cnicas para refactorizar la mayor parte del sistema y pruebas a este estilo.

|                            | Output-based | State-based | Communication-based |
|----------------------------|--------------|-------------|---------------------|
| Resistencia al refactoring | ‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê          | ‚≠ê              |
| Mantenibilidad             | ‚≠ê‚≠ê‚≠ê            | ‚≠ê‚≠ê           | ‚≠ê             |


<small>Comparativa de los 3 estilos</small>

### ¬øQue es la programaci√≥n funcional?
Como ya mencion√©, el estilo de pruebas basado en salidas, es posible solo si lo que se est√° probando est√° escrito en manera puramente funcional, para ello se utiliza la programaci√≥n funcional.

La programaci√≥n funcional, es la programaci√≥n con funciones matem√°ticas o funciones puras, dichas funciones o m√©todos no deben tener ninguna entrada o salida oculta, todas deben estar a la vista, es decir, tienen que ser expl√≠citas o expresadas, tambi√©n una funci√≥n de este tipo, va a producir el mismo resultado para las mismas entradas siempre.

![functional programming](/images/posts/functional_programming.png)
<small>Programaci√≥n funcional</small>

Una funci√≥n matem√°tica simple, donde por cada valor en x hay uno en y.
En la programaci√≥n esto se expresa a trav√©s de la firma o declaraci√≥n del m√©todo, debe tener una lista de par√°metros definida, el nombre del m√©todo, el tipo y valor de retorno.

Recordemos que un cambio de estado o una interacci√≥n de salida tambi√©n son tipos de salidas, pero para este tipo de funciones, la √∫nica salida que debe existir es la que retorna el m√©todo.

![parts of a function](/images/posts/parts_functional_programming.png)
<small>Partes de una funci√≥n</small>

![functional programming outputs](/images/posts/functional_programming_sample.png)


Recapitulando un poco, en el estilo output-based las entradas y salidas deben ser totalmente expl√≠citas y a la vista, representadas por los par√°metros que reciben y el valor de retorno que dan, no m√°s, sin embargo existen m√°s tipos de entradas y salidas ocultas que pueden hacer tu c√≥digo un poco m√°s complejo y menos estable, algunas de estas son:

* üß™Side effects o efectos secundarios, estos no son expresados en la firma del m√©todo, mutan el estado de la clase, de un archivo, etc√©tera.
* ‚ö†Ô∏èExcepciones, cuando dentro de la ejecuci√≥n de un m√©todo alguna instrucci√≥n puede lanzar una excepci√≥n, esta crea una salida distinta que puede o no pasar.
* üïπ Referencia interna o externa, estas son un tipo de entrada oculta, cuando el m√©todo accede a alg√∫n valor de la clase, de la base de datos de manera interna.

Como regla general para determinar si un m√©todo es funcional o similar a una funci√≥n matem√°tica, se debe sustituir f√°cilmente su llamado por un valor que devolver√≠a y esto no debe cambiar el funcionamiento de tu sistema o programa, por ejemplo,en lugar de invocar wholesaleDiscount con una lista de 2 productos puedo utilizar el valor que devolver√≠a ‚û°Ô∏è 0.02.

### ¬øQue es una arquitectura funcional?

A pesar de las bondades y practicidad que tiene escribir tu sistema en manera, no se puede escribir todo un sistema de esta manera, es decir, no se puede crear una aplicaci√≥n que no incurra en ninguna side effect, ser√≠a totalmente impr√°ctica.

Despu√©s de todo una aplicaci√≥n trata de eso, de guardar la informaci√≥n de usuarios, registrar ordenes, compras , estad√≠sticas, etc√©tera.

Por ello la meta de la programaci√≥n funcional no es eliminar los side effects, sino separar la l√≥gica de negocios del c√≥digo que incurre en side effects, y es donde entra la arquitectura funcional.

La arquitectura funcional busca maximizar la cantidad de c√≥digo escrito en manera puramente funcional y minimizar la que incurre en side effects, esta separaci√≥n es por 2 tipos de c√≥digo:


| C√≥digo que toma decisiones                                                                          | C√≥digo que actua basado en esas desiciones                                                                                 |
|-----------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------|
| No requiere incurrir en side-effects y puede ser escrito como una funci√≥n matem√°tica (es inmutable) | Convierte las decisiones en cosas visibles, como cambios a la base de datos, el env√≠o de un mensaje, etc√©tera (es mutable) |

![Esquema simple de la arquitectura funcional](/images/posts/arquitectura_funcional.png)
<small>Esquema simple de la arquitectura funcional</small>


Podemos ver como la parte mutable ofrece las entradas al core funcional, que se encarga de calcular y procesar las decisiones, despu√©s estas las recibe de nuevo la parte mutable para efectuar las acciones visibles.

Ejemplo: Refactorizaci√≥n a arquitectura funcional para utilizar el estilo output-based

https://github.com/Andrew0914/transition_fa <GithubIcon/> 

Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro: 

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).
