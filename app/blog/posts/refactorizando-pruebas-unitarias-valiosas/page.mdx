# Refactorizando para tener pruebas unitarias valiosas
## Unit testing, principios, pr√°cticas y patrones


En el post 1 La meta de las pruebas unitarias üß™, definimos cu√°les son las tres caracter√≠sticas que definen a una buena prueba unitaria, la √∫ltima de ellas: ‚ÄúDeben ofrecer el m√°ximo valor con el m√≠nimo de costo de mantenimiento‚Äú, pero para poder lograr esto necesitamos 2 cosas:

* üß† Reconocer que es una prueba valiosa y cu√°l no lo es
* ‚úçÔ∏è Escribir una prueba unitaria valiosa

En el post Los 4 pilares de una buena prueba unitaria vimos c√≥mo reconocer una prueba unitaria valiosa, pero a lo largo de este post aprenderemos c√≥mo se escriben ese tipo de pruebas, tambi√©n necesitamos tener habilidades de dise√±o en nuestro c√≥digo, ya que ser√≠a imposible hacer una prueba valiosa sin poner un poco de esfuerzo en escribir una buena base de c√≥digo.

Identificar el c√≥digo a refactorizar
Es casi imposible el mejorar una suite de pruebas sin refactorizar nuestra base de c√≥digo mejorandola tambi√©n, ya que la suite de pruebas est√° intr√≠nsecamente conectada a esta base de c√≥digo.

### Los 4 tipos de c√≥digo
Podemos categorizar nuestro c√≥digo en funci√≥n de dos dimensiones:

* üß© Complejidad o significancia de dominio.
* üôã‚Äç‚ôÇÔ∏è Cantidad de colaboradores

La complejidad o significancia de domino est definida por la cantidad de decisiones o punto de ramificaci√≥n que hay el c√≥digo, mientras mayor sea este n√∫mero mayor ser√° la complejidad.

Ejemplo: si en t√∫ c√≥digo no hay ni una sola sentencia `if o un loops`, la complejidad se calcula de la siguiente manera: `1 + branching points`, en este caso ser√≠a 1 + 0 = 1.

Ahora imaginemos que nuestro c√≥digo tiene una sentencia if solamente, la complejidad ser√≠a de `1 + 1 = 2`, si embargo aunque este es un punto de partida, no siempre el c√≥digo complejo tiene significancia de dominio, y el c√≥digo simple tambi√©n puede tener significancia de dominio. La complejidad o significancia de dominio en el c√≥digo est√° directamente relacionado con la meta del usuario final .

La segunda m√©trica que es la cantidad de colaboradores, como ya vimos en posts pasados un colaborador es una dependencia que puede ser mutable u out-of-process o las 2, un c√≥digo con una gran cantidad de colaboradores puede generar pruebas grandes con una amplia y compleja maquinaria de mocks que inmediatamente eleva los costos en t√©rminos de mantenibilidad, por eso es importante tener separada nuestra l√≥gica principal de las interacciones y solo aplicar mocks para las interacciones que est√°n fuera de los l√≠mites de nuestro sistema.

La combinaci√≥n de estas 2 dimensiones nos muestra que existen 4 tipos de c√≥digo:

![4 tipos de c√≥digo](/images/posts/dimensiones_4_tipos_codigo.png)
<small className="text--sm text--muted">4 tipos de c√≥digo</small>



* üß† **Modelo de dominio o algoritmos**: es el c√≥digo que resuelve la meta final del usuario, suele ser complejo pero no siempre ya que puede haber algoritmos complejos que no aportan directamente al modelo de dominio.
* ‚úèÔ∏è **C√≥digo trivial**: este tiene muy pocos colaboradores o ninguno y no tiene relevancia, puede ser por ejemplo la declaraci√≥n de un constructor.
* üöÄ **C√≥digo super complicado**: tiene una alta complejidad y un alto n√∫mero de colaboradores, por ejemplo un fat-controller, donde se ponga toda la l√≥gica e interacciones.
* üïπ **Controladores**: no tiene l√≥gica de negocio cr√≠tica o significativa pero se encarga de coordinar el trabajo de otros componentes , como las clases de modelo y aplicaciones externas.

Esto nos da como conclusi√≥n que el c√≥digo que se categorize en el cuadrante superior izquierdo, nos da la oportunidad de generar pruebas de mayor valor y menos costosas, d√°ndonos una mayor protecci√≥n contra las regresiones y bajos costos de mantenibilidad.

Al c√≥digo trivial casi siempre no vale la pena hacerle pruebas unitarias, ya que el valor que aportan es casi 0.

El cuadrante m√°s problem√°tico, el del c√≥digo super complicado, es bastante dif√≠cil de probar pero muy riesgoso el no hacerlo, este tipo de c√≥digo en un sistema es realmente **la raz√≥n por la cual muchas personas abandonan el hacer pruebas unitarias**, pero no se preocupen, si hay una forma de lidiar con este tipo de c√≥digo, es dividirlo en 2 partes: controladores y algoritmos.

Una vez que se hace esta divisi√≥n, nos enfocamos en los algoritmos para solo obtener pruebas valiosas, si bien no alcanzaremos un 100% de coverage, recordemos que este no es nuestro objetivo sino tener una suite de pruebas que aporte el mayor valor posible.

![Estrategia para el c√≥digo super complicado](/images/posts/estrategia_overcomplicated_code.png)
<small className="text--sm text--muted">Estrategia para el c√≥digo super complicado</small>

### Usando el patr√≥n [Humble-object](https://martinfowler.com/bliki/HumbleObject.html) para dividir c√≥digo super complicado.

A menudo nos encontramos con c√≥digo que es muy dif√≠cil de probar por qu√© porque est√° muy acoplado a las dependencias de un framework, por ejemplo llamadas as√≠ncronas o ejecuciones multi-thread, interfaces de usuario, comunicaci√≥n con dependencias out-of-process y m√°s.

![patr√≥n humble](/images/posts/humble_1.png)
<small className="text--sm text--muted">Patr√≥n humble</small>


Para poder probar necesitamos extraer la l√≥gica importante o que tiene significancia de dominio del c√≥digo con dependencias dif√≠ciles de probar, normalmente se mueve esta l√≥gica a una clase nueva o archivo nuevo, el c√≥digo con dependencias complicadas puede que conserve algunos detalles de l√≥gica pero estos no deber√≠an ser significativos para el dominio y por tanto no se necesita aplicarles pruebas.

![patr√≥n humble](/images/posts/humble_2.png)
<small className="text--sm text--muted">Patr√≥n humble</small>


Podemos ver que ya hemos aplicado este patr√≥n en ejemplos de post anteriores, espec√≠ficamente: Mocks y fragilidad en las pruebas donde vemos que la arquitectura hexagonal busca separar la l√≥gica de negocios de las comunicaciones con dependencias out-of-process,y en Estilos de pruebas unitarias vemos que la arquitectura funcional va todav√≠a m√°s haya separando la l√≥gica de todas las dependencias o colaboradores no solo las out-of-process, por ello es que esta ultima es muy testeable.

![Ejes de arquitectura](/images/posts/arquitecturas_axis.png)
<small className="text--sm text--muted">Ejes de arquitectura</small>

Otra forma de ver el patr√≥n Humble object, es apegarse al principio de que cada componente en tu sistema debe tener una √∫nica responsabilidad, es decir, si una clase o m√≥dulo tiene l√≥gica de negocio su √∫nica responsabilidad debe ser esa.

En resumen tenemos que separar la l√≥gica de negocios del c√≥digo de orquestaci√≥n, tambi√©n podemos ver el c√≥digo en t√©rminos de amplitud(m√°s amplio entre m√°s colaboradores o dependencias) y profundidad(m√°s profundo entre m√°s importancia y complejidad).

![Amplitud y profundidad](/images/posts/amplitud_profundidad.png)
<small className="text--sm text--muted">Amplitud y profundidad</small>

Es tan importante esta separaci√≥n, que este patr√≥n es aplicado a muchas de las arquitecturas m√°s populares como: [MVC](https://desarrolloweb.com/articulos/que-es-mvc.html) (Model-View-Controller), [MVP](https://es.wikipedia.org/wiki/Modelo%E2%80%93vista%E2%80%93presentador) (Model-View-Presenter), donde el Controller y Presenter son controladores y a su vez son humble objects que orquestan y ayudan separar la l√≥gica del modelo de la vista o UI.

#### Ejemplo: Refactorizando para obtener pruebas unitarias valiosas.

[refactoring_toward_valuble_tests üëà üîó](https://github.com/Andrew0914/refactoring_toward_valuble_tests)


Entrar√© en m√°s detalle en pr√≥ximos cap√≠tulos de este post que es un resumen y mi entendimiento del libro: 

[üìñ Unit testing: principles, pratices and patterns‚Äù por Vladimir Khorikov de la editorial Manning](https://www.manning.com/books/unit-testing).
